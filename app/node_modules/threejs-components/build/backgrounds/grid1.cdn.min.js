import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as n,MathUtils as o,Vector2 as r,Color as a,MeshPhysicalMaterial as h,ShaderChunk as c,InstancedMesh as d,Vector3 as m,Object3D as l,FrontSide as p,PointLight as g,LatheGeometry as f,PCFSoftShadowMap as u,Raycaster as v,Plane as y}from"https://cdn.jsdelivr.net/npm/three@0.181.0/+esm";import{EffectComposer as w}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/EffectComposer.js/+esm";import{RenderPass as x}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/RenderPass.js/+esm";import{UnrealBloomPass as z}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/UnrealBloomPass.js/+esm";import{OutputPass as P}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/OutputPass.js/+esm";class R{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#n=!1;isDisposed=!1;#o;#r;#a;#h=new e;#c={elapsed:0,delta:0};#d;#m;#l=0;#p=0;constructor(e){this.#e={...e},this.#g(),this.#f(),this.#u(),this.resize(),this.#v()}#g(){this.camera=new t,this.cameraFov=this.camera.fov}#f(){this.scene=new i}#u(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block",this.canvas.style.touchAction="none";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=n}#v(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#y.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#y.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#o=new IntersectionObserver(this.#w.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#o.observe(this.canvas),document.addEventListener("visibilitychange",this.#x.bind(this))}#z(){window.removeEventListener("resize",this.#y.bind(this)),this.#r?.disconnect(),this.#o?.disconnect(),document.removeEventListener("visibilitychange",this.#x.bind(this))}#w(e){this.#s=e[0].isIntersecting,this.#s?this.#P():this.#R()}#x(e){this.#s&&(document.hidden?this.#R():this.#P())}#y(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#b(),this.#M(),this.onAfterResize(this.size)}#b(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#L(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#L(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#L(e){const t=Math.tan(o.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*o.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#M(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}get fpsLimit(){return this.#m}set fpsLimit(e){this.#m=e,this.#l=e>0?1/e:0}#P(){if(this.#n)return;console.log("Start rendering");const e=()=>{this.#d=requestAnimationFrame(e),this.#c.elapsed=this.#h.getElapsedTime();const t=this.#c.elapsed-this.#p;(!this.#m||this.#m&&t>this.#l)&&(this.#c.delta=t,this.onBeforeRender(this.#c),this.render(),this.onAfterRender(this.#c),this.#p=this.#c.elapsed)};this.#n=!0,this.#h.start(),e()}#R(){this.#n&&(console.log("Stop rendering"),cancelAnimationFrame(this.#d),this.#n=!1,this.#h.stop(),this.#p=0)}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#z(),this.#R(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const b=new Map,M=new r;let L=!1;function C(e){const t={position:new r,nPosition:new r,hover:!1,pressed:!1,onEnter(){},onLeave(){},onMove(){},onDown(){},onUp(){},onClick(){},...e};return function(e,t){b.has(e)||(b.set(e,t),L||(document.body.addEventListener("pointermove",S),document.body.addEventListener("pointerleave",E),document.body.addEventListener("pointerdown",I),document.body.addEventListener("pointerup",O),document.body.addEventListener("click",k),L=!0))}(e.domElement,t),t.dispose=()=>{var t;t=e.domElement,b.delete(t),0===b.size&&(document.body.removeEventListener("pointermove",S),document.body.removeEventListener("pointerleave",E),document.body.removeEventListener("pointerdown",I),document.body.removeEventListener("pointerup",O),document.body.removeEventListener("click",k),L=!1)},t}function A(e,t){M.x=e.clientX,M.y=e.clientY;for(const[e,i]of b){t(i,e.getBoundingClientRect())}}function S(e){A(e,(t,i)=>{T(i)?(D(t,i),t.hover||(t.hover=!0,t.onEnter(t)),t.pressed=e.buttons>0,t.onMove(t)):t.hover&&(t.hover=!1,t.pressed=!1,t.onLeave(t))})}function E(){for(const e of b.values())e.hover&&(e.hover=!1,e.onLeave(e))}function I(e){A(e,(e,t)=>{T(t)&&(D(e,t),e.onDown(e))})}function O(e){A(e,(e,t)=>{T(t)&&(D(e,t),e.onUp(e))})}function k(e){A(e,(e,t)=>{T(t)&&(D(e,t),e.onClick(e))})}function D(e,t){const{position:i,nPosition:s}=e;i.x=M.x-t.left,i.y=M.y-t.top,s.x=i.x/t.width*2-1,s.y=-i.y/t.height*2+1}function T(e){const{x:t,y:i}=M,{left:s,top:n,width:o,height:r}=e;return t>=s&&t<=s+o&&i>=n&&i<=n+r}class j extends h{constructor(e){super(e);this.uniforms={thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}},this.defines.USE_UV="",this.onBeforeCompile=e=>{Object.assign(e.uniforms,this.uniforms),e.fragmentShader="\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n      "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("void main() {","\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {\n          vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          #ifdef USE_COLOR\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;\n          #else\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;\n          #endif\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n      ");const t=c.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );","\n          RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n          RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);\n        ");e.fragmentShader=e.fragmentShader.replace("#include <lights_fragment_begin>",t),this.onBeforeCompile2&&this.onBeforeCompile2(e)}}}const{randFloatSpread:F,smoothstep:V}=o,N={type:"hexagon",n:20,padding:0,light1Color:16777215,light1Intensity:1e3,light1PositionZ:5,light2Color:16711680,light2Intensity:500,light2PositionZ:-20,colors:[255,2105376,16777215],materialParams:{metalness:.8,roughness:.5,clearcoat:1,clearcoatRoughness:.1},timeCoef:1,depthScale:1,tiltRotationX:.15,tiltRotationY:.15};class Z extends d{#C;#c=0;#A;#S;pointerPosition=new m;tilt=new m;#E=new m;#I=new l;#O=new r;constructor(e,t){const i={...N,...t};let s;"triangle"===i.type?(s=3,i.width=100/(i.n/2+.5),i.height=Math.sin(Math.PI/3)*i.width,i.radius=.5*i.width/Math.cos(Math.PI/6),i.nx=i.n,i.ny=Math.floor(3*i.n/5)):"square"===i.type?(s=4,i.width=100/i.n,i.height=100/i.n,i.radius=.5*i.width,i.nx=i.n,i.ny=Math.floor(2*i.n)):(s="hexagon"===i.type?6:16,i.radius=50/i.n,i.nx=i.n,i.ny=i.n);const n=function(e,t,i,s=0,n=0,o=3){const a=[];a.push(new r(t,-i/2));for(let e=0;e<o;e++){const h=t-s+Math.cos(e/(o-1)*Math.PI/2)*s,c=i/2-n+Math.sin(e/(o-1)*Math.PI/2)*n;a.push(new r(h,c))}a.push(new r(0,i/2));const h=new f(a,e);return h.translate(0,-i/2,0),h.rotateX(Math.PI/2),h}(s,i.radius,10*i.radius,.125*i.radius,.125*i.radius);super(n,new j({...i.materialParams,side:p}),i.nx*i.ny),this.#C=e,this.config=i,this.#A=this.#k(),this.#S=new Float32Array(this.count).fill(0).map(()=>F(2*Math.PI)),this.#D(),this.castShadow=!0,this.receiveShadow=!0,this.setColors(i.colors)}#D(){const e=new g(this.config.light1Color,this.config.light1Intensity);e.positionZ=this.config.light1PositionZ,e.castShadow=!0,e.shadow.mapSize.width=2048,e.shadow.mapSize.height=2048,this.light1=e,this.#C.scene.add(this.light1);const t=new g(this.config.light2Color,this.config.light2Intensity);t.positionZ=this.config.light2PositionZ,this.light2=t,this.#C.scene.add(this.light2)}#k(){return"triangle"===this.config.type?function({nx:e,ny:t,width:i,height:s,radius:n}){const o=i/2,r=s,a=-e/2*o+o/2,h=-t/2*r+r/2;return _({nx:e,ny:t},(e,t)=>({x:a+e*o,y:h+t*r+.5*(t%2?-1:1)*(s-n)+e%2*(t%2?1:-1)*(2*n-s),rotZ:(e+t%2)%2*Math.PI/3}))}(this.config):"square"===this.config.type?function({nx:e,ny:t,width:i,height:s}){const n=i,o=s/2,r=-e/2*n+n/4,a=-t/2*o+o/2;return _({nx:e,ny:t},(e,t)=>({x:r+e*n+t%2/2*n,y:a+t*o,rotZ:0}))}(this.config):"hexagon"===this.config.type?function({nx:e,ny:t,radius:i}){const s=Math.cos(Math.PI/6)*i*2,n=1.5*i,o=-e/2*s+s/4,r=-t/2*n+n/2;return _({nx:e,ny:t},(e,t)=>({x:o+e*s+t%2/2*s,y:r+t*n,rotZ:0}))}(this.config):function({nx:e,ny:t,radius:i}){const s=2*i,n=Math.sin(Math.PI/3)*s,o=-e/2*s+s/4,r=-t/2*n+n/2;return _({nx:e,ny:t},(e,t)=>({x:o+e*s+t%2/2*s,y:r+t*n,rotZ:0}))}(this.config)}#T(){for(let e=0;e<this.config.nx;e++)for(let t=0;t<this.config.ny;t++){const i=e*this.config.ny+t,s=this.#A[i],n=this.#O.set(s.x,s.y).multiplyScalar(this.scale.x).sub(this.pointerPosition).length(),o=1-V(n,0,20*this.config.radius);this.#I.position.x=s.x,this.#I.position.y=s.y,this.#I.position.z=.5*(Math.cos(this.#S[i]+this.#c)-1)*this.config.radius*this.config.depthScale*o,this.#I.rotation.z=s.rotZ,this.#I.scale.set(1-this.config.padding,1-this.config.padding,1),this.#I.updateMatrix(),this.setMatrixAt(i,this.#I.matrix)}this.instanceMatrix.needsUpdate=!0}setColors(e){if(Array.isArray(e)&&e.length>1){const t=function(e){let t,i;return s(e),{setColors:s,getColorAt:function(e,s=new a){const n=Math.max(0,Math.min(1,e))*(t.length-1),o=Math.floor(n),r=i[o];if(o>=t.length-1)return r.clone();const h=n-o,c=i[o+1];return s.r=r.r+h*(c.r-r.r),s.g=r.g+h*(c.g-r.g),s.b=r.b+h*(c.b-r.b),s}};function s(e){t=e,i=[],t.forEach(e=>{const t=new a(e);i.push(t)})}}(e);for(let e=0;e<this.count;e++)this.setColorAt(e,t.getColorAt(Math.random()));this.instanceColor.needsUpdate=!0}}resize(){this.#C.size.ratio>1?(this.scale.x=this.#C.size.wWidth/100*1.4,this.scale.y=this.scale.x):(this.scale.y=this.#C.size.wHeight/100*1.4,this.scale.x=this.scale.y)}update(e){this.#c+=e.delta*this.config.timeCoef,this.light1.position.set(this.pointerPosition.x,this.pointerPosition.y,this.light1.positionZ),this.light2.position.set(this.pointerPosition.x,this.pointerPosition.y,this.light2.positionZ),this.#E.lerp(this.tilt,.1),this.rotation.set(this.#E.x*this.config.tiltRotationX,this.#E.y*this.config.tiltRotationY,0),this.#T()}}function _({nx:e,ny:t},i){const s=new Array(e*t).fill(0);for(let n=0;n<e;n++)for(let e=0;e<t;e++){s[n*t+e]=i(n,e)}return s}function W(e,t={}){const i=new R({canvas:e,size:"parent",rendererOptions:{antialias:!0,stencil:!1,depth:!1}});i.cameraMaxAspect=1,i.camera.position.z=100,i.updateWorldSize(),i.renderer.shadowMap.enabled=!0,i.renderer.shadowMap.type=u;const s=new x(i.scene,i.camera),n=new z(new r(i.size.width,i.size.height));n.radius=0,n.strength=.2,n.threshold=0;const o=new P,a=new w(i.renderer);a.addPass(s),a.addPass(n),a.addPass(o),i.postprocessing=a;const h=new Z(i,t);i.scene.add(h),h.resize();const c=new v,d=new y(new m(0,0,1),0),l=new m,p=C({domElement:e});return p.onMove=()=>{c.setFromCamera(p.nPosition,i.camera),i.camera.getWorldDirection(d.normal),c.ray.intersectPlane(d,l),h.tilt.set(-p.nPosition.y,p.nPosition.x,0)},p.onLeave=()=>{l.set(0,0,0),h.tilt.set(0,0,0)},i.onBeforeRender=e=>{h.pointerPosition.lerp(l,.1),h.update(e)},i.onAfterResize=e=>{h.resize()},{three:i,bloomPass:n,grid:h,dispose(){p.dispose(),i.dispose()}}}export{W as default};
