import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as n,MathUtils as o,Color as r,Vector3 as a,Vector2 as h,ShaderMaterial as c,Mesh as l,PlaneGeometry as d,CatmullRomCurve3 as m,OrthographicCamera as p}from"https://cdn.jsdelivr.net/npm/three@0.181.0/+esm";class v{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#n=!1;isDisposed=!1;#o;#r;#a;#h=new e;#c={elapsed:0,delta:0};#l;#d;#m=0;#p=0;constructor(e){this.#e={...e},this.#v(),this.#f(),this.#g(),this.resize(),this.#u()}#v(){this.camera=new t,this.cameraFov=this.camera.fov}#f(){this.scene=new i}#g(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block",this.canvas.style.touchAction="none";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=n}#u(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#z.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#z.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#o=new IntersectionObserver(this.#w.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#o.observe(this.canvas),document.addEventListener("visibilitychange",this.#S.bind(this))}#R(){window.removeEventListener("resize",this.#z.bind(this)),this.#r?.disconnect(),this.#o?.disconnect(),document.removeEventListener("visibilitychange",this.#S.bind(this))}#w(e){this.#s=e[0].isIntersecting,this.#s?this.#b():this.#x()}#S(e){this.#s&&(document.hidden?this.#x():this.#b())}#z(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#y(),this.#C(),this.onAfterResize(this.size)}#y(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#M(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#M(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#M(e){const t=Math.tan(o.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*o.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#C(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}get fpsLimit(){return this.#d}set fpsLimit(e){this.#d=e,this.#m=e>0?1/e:0}#b(){if(this.#n)return;console.log("Start rendering");const e=()=>{this.#l=requestAnimationFrame(e),this.#c.elapsed=this.#h.getElapsedTime();const t=this.#c.elapsed-this.#p;(!this.#d||this.#d&&t>this.#m)&&(this.#c.delta=t,this.onBeforeRender(this.#c),this.render(),this.onAfterRender(this.#c),this.#p=this.#c.elapsed)};this.#n=!0,this.#h.start(),e()}#x(){this.#n&&(console.log("Stop rendering"),cancelAnimationFrame(this.#l),this.#n=!1,this.#h.stop(),this.#p=0)}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#R(),this.#x(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const f={segments:128,colors:["#c7d8e2","#aa3b8c","#3c97ee"],points:[{x:0,y:5,z:20},{x:0,y:0,z:0},{x:0,y:-5,z:20}],closed:!1,offsetScale:{x:10,y:0,z:0},neonSize:5,timeScale:10},{randFloat:g,randFloatSpread:u}=o;function z(e){const i={...f,...e},s=2*i.segments,n={positions:new Array(i.segments).fill().map(()=>new a),colors:new Array(i.segments).fill().map(()=>new r),lengths:new Array(i.segments).fill().map(()=>g(.005,.03)),timeOffsets:new Array(i.segments).fill().map(()=>g(0,1)),velocities:new Array(i.segments).fill().map(()=>g(.5,1))};let o;const p={width:0,height:0},v={value:0},z={value:new h},w={value:i.neonSize},S={value:new Array(s).fill().map(()=>new a)},R={value:n.colors.map(e=>e.clone())},b={uTime:v,uRatio:z,uNeonSize:w,uPoints:S,uColors:R};let x,y,C;const M=new a;return function(){x=new t,x.position.set(0,0,25),x.updateProjectionMatrix(),x.updateMatrixWorld(),y=new c({uniforms:b,defines:{NUM_SEGMENTS:i.segments,NUM_POINTS:s},vertexShader:"varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}",fragmentShader:"uniform vec2 uRatio;uniform float uNeonSize;uniform vec3 uPoints[NUM_POINTS];uniform vec3 uColors[NUM_SEGMENTS];varying vec2 vUv;float sdSegment(in vec2 p,in vec2 a,in vec2 b){vec2 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h);}void main(){vec2 pos=(vUv-0.5)*uRatio;vec3 col=vec3(0.0);for(int i=0;i<NUM_SEGMENTS;i++){vec3 p1=uPoints[i*2];vec3 p2=uPoints[i*2+1];if((p1.z<-1.0||p1.z>1.0)||(p2.z<-1.0||p2.z>1.0))continue;float dist=sdSegment(pos,p1.xy,p2.xy);float glow=uNeonSize/dist;col+=glow*uColors[i];}gl_FragColor=vec4(col,1.0);}"}),C=new l(new d(2,2),y),o=new m([]),A(i.points),o.closed=i.closed;for(let e=0;e<i.segments;e++)n.positions[e].set(u(1),u(1),u(1));P(i.colors)}(),Object.assign(C,{update:function(e){let t,s;v.value+=e.delta*i.timeScale;for(let e=0;e<i.segments;e++){const r=n.positions[e],a=S.value[2*e],h=S.value[2*e+1];if(t=(n.timeOffsets[e]+v.value*n.velocities[e]*.025)%1,s=o.closed?(t+n.lengths[e])%1:Math.min(1,t+n.lengths[e]),o.getPoint(t,a),o.getPoint(s,h),M.x=r.x*i.offsetScale.x,M.y=r.y*i.offsetScale.y,M.z=r.z*i.offsetScale.z,a.add(M),a.project(x),h.add(M),h.project(x),!o.closed){R.value[e].copy(n.colors[e]).multiplyScalar(Math.sin(Math.PI*t))}}},setColors:P,setCurvePoints:A,setCurveClosed:function(e){o.closed=e},setCurveOffsetScale:function(e){i.offsetScale=e},setNeonSize:function(e){i.neonSize=e,p.width>=p.height?w.value=i.neonSize/p.width:w.value=i.neonSize/p.height},setVelocity:function(e){i.timeScale=e},setSize:function(e,t){p.width=e,p.height=t,e>=t?(z.value.set(1,t/e),w.value=i.neonSize/e):(z.value.set(e/t,1),w.value=i.neonSize/t)}}),C;function P(e){const t=function(e){let t,i;return s(e),{setColors:s,getColorAt:function(e,s=new r){const n=Math.max(0,Math.min(1,e))*(t.length-1),o=Math.floor(n),a=i[o];if(o>=t.length-1)return a.clone();const h=n-o,c=i[o+1];return s.r=a.r+h*(c.r-a.r),s.g=a.g+h*(c.g-a.g),s.b=a.b+h*(c.b-a.b),s}};function s(e){t=e,i=[],t.forEach(e=>{const t=new r(e);i.push(t)})}}(e);for(let e=0;e<i.segments;e++)n.colors[e].copy(t.getColorAt(g(0,1))),R.value[e].copy(n.colors[e]);const s=e.map(e=>{const t=new r;return t.set(e),t.getHexString()});console.log("debugColors",s)}function A(e){o.points=e.map(e=>e.isVector3?e:new a(e.x,e.y,e.z))}}function w(e,t={}){const i=new v({canvas:e,size:"parent"});i.maxPixelRatio=1,i.camera=new p;const s=z(t);return s.setSize(i.size.width,i.size.height),i.scene.add(s),i.onBeforeRender=e=>{s.update(e)},i.onAfterResize=e=>{s.setSize(e.width,e.height)},{three:i,neon:s,setColors:s.setColors,setCurvePoints:s.setCurvePoints,setCurveClosed:s.setCurveClosed,setCurveOffsetScale:s.setCurveOffsetScale,setNeonSize:s.setNeonSize,setVelocity:s.setVelocity,dispose:i.dispose.bind(i)}}export{w as default};
