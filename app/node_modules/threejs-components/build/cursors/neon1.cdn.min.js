import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as o,MathUtils as n,Vector2 as r,Color as a,SplineCurve as h,PlaneGeometry as c,ShaderMaterial as d,Mesh as l,OrthographicCamera as p}from"https://cdn.jsdelivr.net/npm/three@0.181.0/+esm";class m{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#o=!1;isDisposed=!1;#n;#r;#a;#h=new e;#c={elapsed:0,delta:0};#d;#l;#p=0;#m=0;constructor(e){this.#e={...e},this.#v(),this.#u(),this.#f(),this.resize(),this.#g()}#v(){this.camera=new t,this.cameraFov=this.camera.fov}#u(){this.scene=new i}#f(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block",this.canvas.style.touchAction="none";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=o}#g(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#w.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#w.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#n=new IntersectionObserver(this.#z.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#n.observe(this.canvas),document.addEventListener("visibilitychange",this.#b.bind(this))}#R(){window.removeEventListener("resize",this.#w.bind(this)),this.#r?.disconnect(),this.#n?.disconnect(),document.removeEventListener("visibilitychange",this.#b.bind(this))}#z(e){this.#s=e[0].isIntersecting,this.#s?this.#x():this.#y()}#b(e){this.#s&&(document.hidden?this.#y():this.#x())}#w(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#P(),this.#C(),this.onAfterResize(this.size)}#P(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#L(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#L(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#L(e){const t=Math.tan(n.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*n.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#C(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}get fpsLimit(){return this.#l}set fpsLimit(e){this.#l=e,this.#p=e>0?1/e:0}#x(){if(this.#o)return;console.log("Start rendering");const e=()=>{this.#d=requestAnimationFrame(e),this.#c.elapsed=this.#h.getElapsedTime();const t=this.#c.elapsed-this.#m;(!this.#l||this.#l&&t>this.#p)&&(this.#c.delta=t,this.onBeforeRender(this.#c),this.render(),this.onAfterRender(this.#c),this.#m=this.#c.elapsed)};this.#o=!0,this.#h.start(),e()}#y(){this.#o&&(console.log("Stop rendering"),cancelAnimationFrame(this.#d),this.#o=!1,this.#h.stop(),this.#m=0)}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#R(),this.#y(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const v=new Map,u=new r;let f=!1;function g(e){const t={position:new r,nPosition:new r,hover:!1,pressed:!1,onEnter(){},onLeave(){},onMove(){},onDown(){},onUp(){},onClick(){},...e};return function(e,t){v.has(e)||(v.set(e,t),f||(document.body.addEventListener("pointermove",z),document.body.addEventListener("pointerleave",b),document.body.addEventListener("pointerdown",R),document.body.addEventListener("pointerup",x),document.body.addEventListener("click",y),f=!0))}(e.domElement,t),t.dispose=()=>{var t;t=e.domElement,v.delete(t),0===v.size&&(document.body.removeEventListener("pointermove",z),document.body.removeEventListener("pointerleave",b),document.body.removeEventListener("pointerdown",R),document.body.removeEventListener("pointerup",x),document.body.removeEventListener("click",y),f=!1)},t}function w(e,t){u.x=e.clientX,u.y=e.clientY;for(const[e,i]of v){t(i,e.getBoundingClientRect())}}function z(e){w(e,(t,i)=>{C(i)?(P(t,i),t.hover||(t.hover=!0,t.onEnter(t)),t.pressed=e.buttons>0,t.onMove(t)):t.hover&&(t.hover=!1,t.pressed=!1,t.onLeave(t))})}function b(){for(const e of v.values())e.hover&&(e.hover=!1,e.onLeave(e))}function R(e){w(e,(e,t)=>{C(t)&&(P(e,t),e.onDown(e))})}function x(e){w(e,(e,t)=>{C(t)&&(P(e,t),e.onUp(e))})}function y(e){w(e,(e,t)=>{C(t)&&(P(e,t),e.onClick(e))})}function P(e,t){const{position:i,nPosition:s}=e;i.x=u.x-t.left,i.y=u.y-t.top,s.x=i.x/t.width*2-1,s.y=-i.y/t.height*2+1}function C(e){const{x:t,y:i}=u,{left:s,top:o,width:n,height:r}=e;return t>=s&&t<=s+n&&i>=o&&i<=o+r}const L={colors:[255,16711680],shaderPoints:16,curvePoints:64,curveLerp1:.5,curveLerp2:.5,radius1:5,radius2:5,sleepRadiusX:50,sleepRadiusY:50,sleepTimeScale1:2,sleepTimeScale2:2};function k(e){const t={...L,...e},i={width:0,height:0},s=function(e){let t,i;return s(e),{setColors:s,getColorAt:function(e,s=new a){const o=Math.max(0,Math.min(1,e))*(t.length-1),n=Math.floor(o),r=i[n];if(n>=t.length-1)return r.clone();const h=o-n,c=i[n+1];return s.r=r.r+h*(c.r-r.r),s.g=r.g+h*(c.g-r.g),s.b=r.b+h*(c.b-r.b),s}};function s(e){t=e,i=[],t.forEach(e=>{const t=new a(e);i.push(t)})}}(t.colors),o=new Array(t.curvePoints).fill(0).map(()=>new r),n=new h(o),p=new r;let m=0,v=0;const u={value:new r},f={value:new r},g={value:new Array(t.shaderPoints).fill(0).map(()=>new r)},w={value:new a(16711935)},z={uRatio:u,uNeonSize:f,uPoints:g,uColor:w};let b,R;return function(){const e=new c(2,2);b=new d({uniforms:z,defines:{SHADER_POINTS:t.shaderPoints},vertexShader:"varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}",fragmentShader:"float sdBezier(vec2 pos,vec2 A,vec2 B,vec2 C){vec2 a=B-A;vec2 b=A-2.0*B+C;vec2 c=a*2.0;vec2 d=A-pos;float kk=1.0/dot(b,b);float kx=kk*dot(a,b);float ky=kk*(2.0*dot(a,a)+dot(d,b))/3.0;float kz=kk*dot(d,a);float res=0.0;float p=ky-kx*kx;float p3=p*p*p;float q=kx*(2.0*kx*kx-3.0*ky)+kz;float h=q*q+4.0*p3;if(h>=0.0){h=sqrt(h);vec2 x=(vec2(h,-h)-q)/2.0;vec2 uv=sign(x)*pow(abs(x),vec2(1.0/3.0));float t=uv.x+uv.y-kx;t=clamp(t,0.0,1.0);vec2 qos=d+(c+b*t)*t;res=length(qos);}else{float z=sqrt(-p);float v=acos(q/(p*z*2.0))/3.0;float m=cos(v);float n=sin(v)*1.732050808;vec3 t=vec3(m+m,-n-m,n-m)*z-kx;t=clamp(t,0.0,1.0);vec2 qos=d+(c+b*t.x)*t.x;float dis=dot(qos,qos);res=dis;qos=d+(c+b*t.y)*t.y;dis=dot(qos,qos);res=min(res,dis);qos=d+(c+b*t.z)*t.z;dis=dot(qos,qos);res=min(res,dis);res=sqrt(res);}return res;}uniform vec2 uRatio;uniform vec2 uNeonSize;uniform vec2 uPoints[SHADER_POINTS];uniform vec3 uColor;varying vec2 vUv;void main(){vec2 pos=(vUv-0.5)*uRatio;vec2 c=(uPoints[0]+uPoints[1])/2.0;vec2 c_prev;float dist=10000.0;for(int i=0;i<SHADER_POINTS-1;i++){c_prev=c;c=(uPoints[i]+uPoints[i+1])/2.0;dist=min(dist,sdBezier(pos,c_prev,uPoints[i],c));}dist=max(0.0,dist);float glow=uNeonSize.y/dist;vec3 col=vec3(0.0);col+=10.0*vec3(smoothstep(uNeonSize.x,0.0,dist));col+=glow*uColor;col=1.0-exp(-col);col=pow(col,vec3(0.5));gl_FragColor=vec4(col,glow);}"}),R=new l(e,b)}(),Object.assign(R,{config:t,update:function({time:e,pointer:r}){if(r.hover)p.x=.5*r.nPosition.x*u.value.x,p.y=.5*r.nPosition.y*u.value.y,v=Math.min(n.points[0].distanceTo(p)/.05,1),m+=.05*(v-m),s.getColorAt(m,w.value);else{const o=e.elapsed*t.sleepTimeScale1,n=e.elapsed*t.sleepTimeScale2,r=Math.cos(o),a=Math.sin(n),h=t.sleepRadiusX/(i.width/u.value.x),c=t.sleepRadiusY/(i.height/u.value.y);p.x=h*r,p.y=c*a,s.getColorAt(.5+.5*Math.cos(e.elapsed),w.value)}n.points[0].lerp(p,t.curveLerp1);for(let e=1;e<t.curvePoints;e++)o[e].lerp(o[e-1],t.curveLerp2);for(let e=0;e<t.shaderPoints;e++)n.getPoint(e/(t.shaderPoints-1),g.value[e])},setColors:function(e){t.colors=e,s.setColors(e)},setSize:function(e,t){i.width=e,i.height=t,x()},updateUniforms:x}),R;function x(){f.value.set(t.radius1,t.radius2),i.width>=i.height?(u.value.set(1,i.height/i.width),f.value.multiplyScalar(1/i.width)):(u.value.set(i.width/i.height,1),f.value.multiplyScalar(1/i.height))}}function A(e,t={}){const i=new m({canvas:e,size:"parent",rendererOptions:{alpha:!0}});i.camera=new p;const s=k(t);s.setSize(i.size.width,i.size.height),i.scene.add(s);const o=g({domElement:i.canvas});return i.onBeforeRender=e=>{s.update({time:e,pointer:o})},i.onAfterResize=e=>{s.setSize(e.width,e.height)},{three:i,neon:s,neonConfig:s.config,setColors:s.setColors,dispose:()=>{o.dispose(),i.dispose()}}}export{A as default};
