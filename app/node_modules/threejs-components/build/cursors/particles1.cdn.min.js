import{Clock as e,PerspectiveCamera as i,Scene as t,WebGLRenderer as s,SRGBColorSpace as n,MathUtils as o,Vector2 as r,Color as a,Object3D as c,Vector3 as h,HalfFloatType as p,PointsMaterial as v,AdditiveBlending as d,Points as l,TextureLoader as m,BufferGeometry as g,Float32BufferAttribute as u}from"https://cdn.jsdelivr.net/npm/three@0.181.0/+esm";import{EffectComposer as f}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/EffectComposer.js/+esm";import{RenderPass as x}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/RenderPass.js/+esm";import{UnrealBloomPass as z}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/UnrealBloomPass.js/+esm";import{OutputPass as y}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/postprocessing/OutputPass.js/+esm";import{GPUComputationRenderer as w}from"https://cdn.jsdelivr.net/npm/three@0.181.0/examples/jsm/misc/GPUComputationRenderer.js/+esm";class b{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#i;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#t;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#n=!1;isDisposed=!1;#o;#r;#a;#c=new e;#h={elapsed:0,delta:0};#p;#v;#d=0;#l=0;constructor(e){this.#e={...e},this.#m(),this.#g(),this.#u(),this.resize(),this.#f()}#m(){this.camera=new i,this.cameraFov=this.camera.fov}#g(){this.scene=new t}#u(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block",this.canvas.style.touchAction="none";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=n}#f(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#x.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#x.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#o=new IntersectionObserver(this.#z.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#o.observe(this.canvas),document.addEventListener("visibilitychange",this.#y.bind(this))}#w(){window.removeEventListener("resize",this.#x.bind(this)),this.#r?.disconnect(),this.#o?.disconnect(),document.removeEventListener("visibilitychange",this.#y.bind(this))}#z(e){this.#s=e[0].isIntersecting,this.#s?this.#b():this.#C()}#y(e){this.#s&&(document.hidden?this.#C():this.#b())}#x(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,i;this.#e.size instanceof Object?(e=this.#e.size.width,i=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,i=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,i=window.innerHeight),this.size.width=e,this.size.height=i,this.size.ratio=e/i,this.#S(),this.#R(),this.onAfterResize(this.size)}#S(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#P(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#P(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#P(e){const i=Math.tan(o.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*o.radToDeg(Math.atan(i))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#R(){this.renderer.setSize(this.size.width,this.size.height),this.#i?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#i}set postprocessing(e){this.#i=e,this.render=e.render.bind(e)}get fpsLimit(){return this.#v}set fpsLimit(e){this.#v=e,this.#d=e>0?1/e:0}#b(){if(this.#n)return;console.log("Start rendering");const e=()=>{this.#p=requestAnimationFrame(e),this.#h.elapsed=this.#c.getElapsedTime();const i=this.#h.elapsed-this.#l;(!this.#v||this.#v&&i>this.#d)&&(this.#h.delta=i,this.onBeforeRender(this.#h),this.render(),this.onAfterRender(this.#h),this.#l=this.#h.elapsed)};this.#n=!0,this.#c.start(),e()}#C(){this.#n&&(console.log("Stop rendering"),cancelAnimationFrame(this.#p),this.#n=!1,this.#c.stop(),this.#l=0)}#t(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(i=>{const t=e.material[i];null!==t&&"object"==typeof t&&"function"==typeof t.dispose&&t.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#w(),this.#C(),this.clear(),this.#i?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const C=new Map,S=new r;let R=!1;function P(e){const i={position:new r,nPosition:new r,hover:!1,pressed:!1,onEnter(){},onLeave(){},onMove(){},onDown(){},onUp(){},onClick(){},...e};return function(e,i){C.has(e)||(C.set(e,i),R||(document.body.addEventListener("pointermove",M),document.body.addEventListener("pointerleave",L),document.body.addEventListener("pointerdown",V),document.body.addEventListener("pointerup",A),document.body.addEventListener("click",E),R=!0))}(e.domElement,i),i.dispose=()=>{var i;i=e.domElement,C.delete(i),0===C.size&&(document.body.removeEventListener("pointermove",M),document.body.removeEventListener("pointerleave",L),document.body.removeEventListener("pointerdown",V),document.body.removeEventListener("pointerup",A),document.body.removeEventListener("click",E),R=!1)},i}function T(e,i){S.x=e.clientX,S.y=e.clientY;for(const[e,t]of C){i(t,e.getBoundingClientRect())}}function M(e){T(e,(i,t)=>{F(t)?(D(i,t),i.hover||(i.hover=!0,i.onEnter(i)),i.pressed=e.buttons>0,i.onMove(i)):i.hover&&(i.hover=!1,i.pressed=!1,i.onLeave(i))})}function L(){for(const e of C.values())e.hover&&(e.hover=!1,e.onLeave(e))}function V(e){T(e,(e,i)=>{F(i)&&(D(e,i),e.onDown(e))})}function A(e){T(e,(e,i)=>{F(i)&&(D(e,i),e.onUp(e))})}function E(e){T(e,(e,i)=>{F(i)&&(D(e,i),e.onClick(e))})}function D(e,i){const{position:t,nPosition:s}=e;t.x=S.x-i.left,t.y=S.y-i.top,s.x=t.x/i.width*2-1,s.y=-t.y/i.height*2+1}function F(e){const{x:i,y:t}=S,{left:s,top:n,width:o,height:r}=e;return i>=s&&i<=s+o&&t>=n&&t<=n+r}const{randFloat:j}=o,I={gpgpuSize:512,size:5,colors:[65280,255],color:16711680,decay:.0025,noiseCoordScale:.5,noiseIntensity:.001,noiseTimeCoef:.1,sleepRadiusX:200,sleepRadiusY:200,sleepTimeScale1:1,sleepTimeScale2:1};class _ extends c{#T;#M;#L;#V;uniforms;#A;#E;#D;#F=new h;constructor(e,i={}){super(),this.config={...I,...i},this.#T=e,this.#M=e.renderer,this.#V={uTime:{value:0},uPointerPosition:{value:new h},uPointerDirection:{value:new h},uDecay:{value:this.config.decay},uNoiseCoordScale:{value:this.config.noiseCoordScale},uNoiseIntensity:{value:this.config.noiseIntensity},uColor:{value:new a(this.config.color)},uPointSize:{value:this.config.size}},this.uniforms={tPosition:{value:null},tVelocity:{value:null},...this.#V},this.#j(),this.#I()}#j(){this.#A=new w(this.config.gpgpuSize,this.config.gpgpuSize,this.#M),this.#M.capabilities.isWebGL2||this.#A.setDataType(p),this.#E=this.#A.createTexture(),this.#D=this.#A.createTexture(),this.#_(this.#E,this.#D),this.velocityVariable=this.#A.addVariable("textureVelocity","\n      vec4 permute(vec4 x){vec4 xm=mod(x,289.0);return mod(((xm*34.0)+10.0)*xm,289.0);}float psrdnoise(vec3 x,vec3 period,float alpha,out vec3 gradient){\n#ifndef PERLINGRID\nconst mat3 M=mat3(0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0);const mat3 Mi=mat3(-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5);\n#endif\nvec3 uvw;\n#ifndef PERLINGRID\nuvw=M*x;\n#else\nuvw=x+dot(x,vec3(1.0/3.0));\n#endif\nvec3 i0=floor(uvw);vec3 f0=fract(uvw);vec3 g_=step(f0.xyx,f0.yzz);vec3 l_=1.0-g_;vec3 g=vec3(l_.z,g_.xy);vec3 l=vec3(l_.xy,g_.z);vec3 o1=min(g,l);vec3 o2=max(g,l);vec3 i1=i0+o1;vec3 i2=i0+o2;vec3 i3=i0+vec3(1.0);vec3 v0,v1,v2,v3;\n#ifndef PERLINGRID\nv0=Mi*i0;v1=Mi*i1;v2=Mi*i2;v3=Mi*i3;\n#else\nv0=i0-dot(i0,vec3(1.0/6.0));v1=i1-dot(i1,vec3(1.0/6.0));v2=i2-dot(i2,vec3(1.0/6.0));v3=i3-dot(i3,vec3(1.0/6.0));\n#endif\nvec3 x0=x-v0;vec3 x1=x-v1;vec3 x2=x-v2;vec3 x3=x-v3;if(any(greaterThan(period,vec3(0.0)))){vec4 vx=vec4(v0.x,v1.x,v2.x,v3.x);vec4 vy=vec4(v0.y,v1.y,v2.y,v3.y);vec4 vz=vec4(v0.z,v1.z,v2.z,v3.z);if(period.x>0.0)vx=mod(vx,period.x);if(period.y>0.0)vy=mod(vy,period.y);if(period.z>0.0)vz=mod(vz,period.z);\n#ifndef PERLINGRID\ni0=M*vec3(vx.x,vy.x,vz.x);i1=M*vec3(vx.y,vy.y,vz.y);i2=M*vec3(vx.z,vy.z,vz.z);i3=M*vec3(vx.w,vy.w,vz.w);\n#else\nv0=vec3(vx.x,vy.x,vz.x);v1=vec3(vx.y,vy.y,vz.y);v2=vec3(vx.z,vy.z,vz.z);v3=vec3(vx.w,vy.w,vz.w);i0=v0+dot(v0,vec3(1.0/3.0));i1=v1+dot(v1,vec3(1.0/3.0));i2=v2+dot(v2,vec3(1.0/3.0));i3=v3+dot(v3,vec3(1.0/3.0));\n#endif\ni0=floor(i0+0.5);i1=floor(i1+0.5);i2=floor(i2+0.5);i3=floor(i3+0.5);}vec4 hash=permute(permute(permute(vec4(i0.z,i1.z,i2.z,i3.z))+vec4(i0.y,i1.y,i2.y,i3.y))+vec4(i0.x,i1.x,i2.x,i3.x));vec4 theta=hash*3.883222077;vec4 sz=hash*-0.006920415+0.996539792;vec4 psi=hash*0.108705628;vec4 Ct=cos(theta);vec4 St=sin(theta);vec4 sz_prime=sqrt(1.0-sz*sz);vec4 gx,gy,gz;\n#ifdef FASTROTATION\nvec4 qx=St;vec4 qy=-Ct;vec4 qz=vec4(0.0);vec4 px=sz*qy;vec4 py=-sz*qx;vec4 pz=sz_prime;psi+=alpha;vec4 Sa=sin(psi);vec4 Ca=cos(psi);gx=Ca*px+Sa*qx;gy=Ca*py+Sa*qy;gz=Ca*pz+Sa*qz;\n#else\nif(alpha!=0.0){vec4 Sp=sin(psi);vec4 Cp=cos(psi);vec4 px=Ct*sz_prime;vec4 py=St*sz_prime;vec4 pz=sz;vec4 Ctp=St*Sp-Ct*Cp;vec4 qx=mix(Ctp*St,Sp,sz);vec4 qy=mix(-Ctp*Ct,Cp,sz);vec4 qz=-(py*Cp+px*Sp);vec4 Sa=vec4(sin(alpha));vec4 Ca=vec4(cos(alpha));gx=Ca*px+Sa*qx;gy=Ca*py+Sa*qy;gz=Ca*pz+Sa*qz;}else{gx=Ct*sz_prime;gy=St*sz_prime;gz=sz;}\n#endif\nvec3 g0=vec3(gx.x,gy.x,gz.x);vec3 g1=vec3(gx.y,gy.y,gz.y);vec3 g2=vec3(gx.z,gy.z,gz.z);vec3 g3=vec3(gx.w,gy.w,gz.w);vec4 w=0.5-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3));w=max(w,0.0);vec4 w2=w*w;vec4 w3=w2*w;vec4 gdotx=vec4(dot(g0,x0),dot(g1,x1),dot(g2,x2),dot(g3,x3));float n=dot(w3,gdotx);vec4 dw=-6.0*w2*gdotx;vec3 dn0=w3.x*g0+dw.x*x0;vec3 dn1=w3.y*g1+dw.y*x1;vec3 dn2=w3.z*g2+dw.z*x2;vec3 dn3=w3.w*g3+dw.w*x3;gradient=39.5*(dn0+dn1+dn2+dn3);return 39.5*n;}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0; vel.y = 0.0; vel.z = 0.0;\n        } else {\n          vec3 grad;\n          psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0.0), uTime, grad);\n          vel.xyz += grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    ",this.#D),this.positionVariable=this.#A.addVariable("texturePosition","\n      uniform float uDecay;\n      uniform vec3 uPointerPosition;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uDecay;\n        if (pos.w <= 0.0) {\n          pos.xyz = uPointerPosition;\n        } else {\n          pos.xyz += vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    ",this.#E),this.#A.setVariableDependencies(this.velocityVariable,[this.positionVariable,this.velocityVariable]),this.#A.setVariableDependencies(this.positionVariable,[this.positionVariable,this.velocityVariable]),this.#A.uniforms={...this.#V},Object.assign(this.velocityVariable.material.uniforms,this.#A.uniforms),Object.assign(this.positionVariable.material.uniforms,this.#A.uniforms);const e=this.#A.init();if(null!==e)throw new Error(e)}#_(e,i){const t=new h,s=e.image.data,n=i.image.data;for(let e=0;e<this.config.gpgpuSize;e++)for(let i=0;i<this.config.gpgpuSize;i++){const o=4*(e+i*this.config.gpgpuSize);t.x=e/this.config.gpgpuSize-.5,t.y=i/this.config.gpgpuSize-.5,t.toArray(s,o),s[o+3]=j(.1,1),t.set(0,0,0).toArray(n,o),n[o+3]=j(.1,1)}}#I(){this.geometry=function(e){const i=new g,t=new Float32Array(e*e*3).fill(0),s=new Float32Array(e*e*2),n=new Float32Array(e*e*3);for(let i=0;i<e;i++)for(let t=0;t<e;t++){const n=i*e+t;s[2*n]=i/e,s[2*n+1]=t/e}return i.setAttribute("position",new u(t,3)),i.setAttribute("positionUv",new u(s,2)),i.setAttribute("color",new u(n,3)),i}(this.config.gpgpuSize),this.setColors(this.config.colors),this.material=new v({blending:d,depthTest:!1,depthWrite:!1,size:this.config.size,sizeAttenuation:!1,transparent:!0,vertexColors:!0}),this.config.map&&this.loadMap(this.config.map),this.material.onBeforeCompile=e=>{Object.assign(e.uniforms,this.uniforms),e.vertexShader="\n        uniform sampler2D tPosition;\n        uniform sampler2D tVelocity;\n        uniform float uPointSize;\n        attribute vec2 positionUv;\n        varying float alpha;\n      "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","\n        vec4 pos = texture2D(tPosition, positionUv);\n        vec4 vel = texture2D(tVelocity, positionUv);\n        vec3 transformed = pos.xyz;\n        alpha = pos.w;\n      "),e.vertexShader=e.vertexShader.replace("gl_PointSize = size;","\n        gl_PointSize = uPointSize * pos.w * (vel.w + 0.5);\n      "),e.fragmentShader="\n        uniform vec3 uColor;\n        varying float alpha;\n      "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("#include <color_fragment>","\n        #ifndef USE_MAP\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n        #endif\n        diffuseColor *= vec4(mix(vColor, uColor, alpha), alpha);\n      ")},this.particles=new l(this.geometry,this.material),this.add(this.particles)}loadMap(e){null===e?(this.material.map=null,this.material.needsUpdate=!0):(this.#L||(this.#L=new m),this.material.map=this.#L.load(e),this.material.needsUpdate=!0)}setColors(e){const i=this.geometry.attributes.color.array,t=function(e){let i,t;return s(e),{setColors:s,getColorAt:function(e,s=new a){const n=Math.max(0,Math.min(1,e))*(i.length-1),o=Math.floor(n),r=t[o];if(o>=i.length-1)return r.clone();const c=n-o,h=t[o+1];return s.r=r.r+c*(h.r-r.r),s.g=r.g+c*(h.g-r.g),s.b=r.b+c*(h.b-r.b),s}};function s(e){i=e,t=[],i.forEach(e=>{const i=new a(e);t.push(i)})}}(e),s=new a;for(let e=0;e<this.config.gpgpuSize*this.config.gpgpuSize;e++)t.getColorAt(Math.random(),s),s.toArray(i,3*e);this.geometry.attributes.color.needsUpdate=!0}update({time:e,pointer:i}){if(this.uniforms.uTime.value+=e.delta*this.config.noiseTimeCoef,i.hover)this.#F.x=i.nPosition.x*this.#T.size.wWidth*.5,this.#F.y=i.nPosition.y*this.#T.size.wHeight*.5;else{const i=e.elapsed*this.config.sleepTimeScale1,t=e.elapsed*this.config.sleepTimeScale2,s=Math.cos(i),n=Math.sin(t),o=this.config.sleepRadiusX*(this.#T.size.wWidth/this.#T.size.width),r=this.config.sleepRadiusY*(this.#T.size.wHeight/this.#T.size.height);this.#F.x=o*s,this.#F.y=r*n}this.uniforms.uPointerPosition.value.lerp(this.#F,.1),this.#A.compute(),this.uniforms.tPosition.value=this.#A.getCurrentRenderTarget(this.positionVariable).texture,this.uniforms.tVelocity.value=this.#A.getCurrentRenderTarget(this.velocityVariable).texture}dispose(){this.#A.dispose()}}function O(e,i={}){const t=new b({canvas:e,size:"parent",rendererOptions:{alpha:!0,antialias:!1,stencil:!1,depth:!1}});t.camera.position.z=50,t.updateWorldSize();const s=new x(t.scene,t.camera),n=new z(new r(t.size.width,t.size.height));n.radius=0,n.strength=.1,n.threshold=0;const o=new y,a=new f(t.renderer);a.addPass(s),a.addPass(n),a.addPass(o),t.postprocessing=a;const c=new _(t,i);t.scene.add(c);const h=P({domElement:e});return t.onBeforeRender=e=>{c.update({time:e,pointer:h})},{three:t,bloomPass:n,particles:c,dispose(){h.dispose(),c.dispose(),t.dispose()}}}export{O as default};
