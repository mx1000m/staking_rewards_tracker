"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
exports.configFromFetch = configFromFetch;
const events_1 = require("events");
const package_json_1 = __importDefault(require("../package.json"));
const picocolors_1 = require("picocolors");
const undici_1 = require("undici");
require("./sentry.js");
const exporter_js_1 = require("./exporter.js");
const api_client_js_1 = require("./generated/api-client.js");
const stackblitz_js_1 = require("./stackblitz.js");
const cac_1 = require("cac");
const child_process_1 = require("child_process");
const util_1 = require("util");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importStar(require("path"));
const css_js_1 = require("./css.js");
const utils_js_1 = require("./utils.js");
const package_manager_js_1 = require("./package-manager.js");
const sentry_js_1 = require("./sentry.js");
const undici_dispatcher_js_1 = require("./undici-dispatcher.js");
const configNames = ['unframer.config.json', 'unframer.json'];
exports.cli = (0, cac_1.cac)('unframer');
let defaultOutDir = 'framer';
exports.cli.command('[projectId]', 'Run unframer with optional project ID')
    .option('--outDir <dir>', 'Output directory', { default: defaultOutDir })
    .option('--external [package]', 'Make some package external, do not pass a package name to make all packages external', {
    default: true,
})
    .option('--watch', 'Watch for changes and rebuild', { default: false })
    .option('--jsx', 'Output jsx code instead of minified .js code', {
    default: true,
})
    .option('--debug', 'Enable debug logging', { default: false })
    .option('--metafile', 'Generate meta.json file with build metadata', {
    default: false,
})
    .action(async function main(projectId, options) {
    const external_ = options.external;
    const allExternal = external_ === true;
    const externalPackages = Array.isArray(external_)
        ? external_.filter((x) => x.trim())
        : typeof external_ === 'string'
            ? [external_]
            : [];
    try {
        if (options.debug) {
            utils_js_1.logger.debug = true;
        }
        const outDir = options.outDir;
        const controller = new AbortController();
        const signal = controller.signal;
        const watch = options.watch;
        if (projectId) {
            const { config, cwd, websiteUrl } = await configFromFetch({
                allExternal,
                externalPackages,
                outDir,
                projectId,
            });
            let jsx = options.jsx;
            const { rebuild, buildContext } = await (0, exporter_js_1.bundle)({
                config: {
                    jsx,
                    ...config,
                },
                watch,
                cwd,
                signal,
                metafile: options.metafile,
            });
            // console.log('buildContext', buildContext)
            if (!websiteUrl || !options.watch) {
                await buildContext?.dispose?.();
                return;
            }
            utils_js_1.spinner.start(`Waiting for changes, try editing a component in Framer and click publish...`);
            let lastEtag = null;
            const startTime = Date.now();
            while (Date.now() - startTime < 30 * 60 * 1000) {
                const etag = await (0, undici_1.fetch)(websiteUrl, {
                    method: 'HEAD',
                    dispatcher: undici_dispatcher_js_1.dispatcher,
                })
                    .then((response) => response.headers.get('etag'))
                    .catch((error) => {
                    utils_js_1.logger.error('Error fetching etag:', error);
                    return null;
                });
                utils_js_1.logger.log('etag', etag);
                if (etag && lastEtag && etag !== lastEtag) {
                    utils_js_1.spinner.start(`Detected Framer website change, rebuilding...`);
                    lastEtag = etag;
                    await rebuild();
                }
                if (etag) {
                    lastEtag = etag;
                }
                await (0, utils_js_1.sleep)(1000 * 2);
            }
        }
        // legacy behavior without Framer plugin
        fixOldUnframerPath();
        const cwd = process.cwd();
        utils_js_1.logger.log(`Looking for ${configNames.join(', ')} in ${cwd}`);
        const configPath = findUp(configNames, { cwd });
        if (!configPath) {
            utils_js_1.logger.log(`No ${configNames.join(', ')} found`);
            return;
        }
        const configBasename = (0, path_1.basename)(configPath);
        const configContent = fs_1.default.readFileSync(configPath, 'utf8');
        if (!configContent) {
            utils_js_1.logger.log(`No ${configBasename} contents found`);
            return;
        }
        const configContentWithoutComments = configContent.replace(/^\s*\/\/.*$/gm, '');
        const config = JSON.parse(configContentWithoutComments);
        if (outDir !== defaultOutDir) {
            config.outDir = outDir;
        }
        (0, events_1.setMaxListeners)(0, controller.signal);
        const { buildContext } = await (0, exporter_js_1.bundle)({
            config: { ...config, externalPackages, allExternal },
            watch,
            signal: controller.signal,
            cwd: path_1.default.resolve(process.cwd(), config.outDir || 'framer'),
            metafile: options.metafile,
        });
        await buildContext.dispose?.();
    }
    catch (error) {
        (0, sentry_js_1.notifyError)(error);
        throw error;
    }
});
function fixOldUnframerPath() {
    // if unframer.json exists, rename it to unframer.config.json
    const oldConfigPath = fs_1.default.existsSync('unframer.json');
    if (oldConfigPath) {
        fs_1.default.renameSync('unframer.json', 'unframer.config.json');
        utils_js_1.logger.green('legacy unframer.json config renamed to unframer.config.json');
        return true;
    }
    return false;
}
const version = package_json_1.default.version;
exports.cli.version(version).help();
exports.cli.command('example-app <projectId>', 'Create an example app with Framer components')
    .option('--outDir <dir>', 'Output directory', {
    default: 'example-unframer-app',
})
    .action(async (projectId, options) => {
    if (!projectId?.trim()) {
        console.log(`unframer example-app requires a project id positional param`);
        process.exit(1);
    }
    try {
        const outDir = options.outDir;
        console.log(`Creating example app in ${outDir}`);
        // Create the output directory
        const absoluteOutDir = path_1.default.resolve(process.cwd(), outDir);
        if (!fs_1.default.existsSync(absoluteOutDir)) {
            fs_1.default.mkdirSync(absoluteOutDir, { recursive: true });
        }
        // Fetch the project configuration
        utils_js_1.spinner.start('Fetching project configuration...');
        const { config, websiteUrl } = await configFromFetch({
            projectId,
            allExternal: true,
            externalPackages: [],
            outDir: 'src/framer',
        });
        utils_js_1.spinner.stop('Project configuration fetched');
        // Generate example component code
        utils_js_1.spinner.start('Generating example component code...');
        const { exampleCode } = await (0, exporter_js_1.createExampleComponentCode)({
            outDir: './framer',
            config,
        });
        // Generate all the files needed for the example app
        const files = (0, stackblitz_js_1.generateStackblitzFiles)({
            projectId,
            appComponentCode: exampleCode,
            title: config.projectName || 'Unframer Example App',
        });
        // Write all files to the output directory
        for (const file of files) {
            const filePath = path_1.default.join(absoluteOutDir, file.relativePath);
            const fileDir = path_1.default.dirname(filePath);
            // Ensure directory exists
            if (!fs_1.default.existsSync(fileDir)) {
                fs_1.default.mkdirSync(fileDir, { recursive: true });
            }
            fs_1.default.writeFileSync(filePath, file.contents);
            console.log(`Created ${file.relativePath}`);
        }
        utils_js_1.spinner.stop('Example files created');
        // Bundle the Framer components
        utils_js_1.spinner.start('Downloading Framer components...');
        const componentsOutDir = path_1.default.join(absoluteOutDir, 'src/framer');
        const { buildContext } = await (0, exporter_js_1.bundle)({
            config: {
                ...config,
                jsx: true,
                outDir: componentsOutDir,
                allExternal: true,
                externalPackages: [],
            },
            watch: false,
            cwd: componentsOutDir,
            signal: new AbortController().signal,
            metafile: false,
        });
        await buildContext?.dispose?.();
        utils_js_1.spinner.stop('Framer components downloaded');
        // Install dependencies using detected package manager
        utils_js_1.spinner.stop('Framer components downloaded');
        const packageManager = await (0, package_manager_js_1.getPackageManager)();
        const installCommand = packageManager === 'yarn' ? 'yarn' : `${packageManager} install`;
        console.log(`Installing dependencies with ${packageManager}...`);
        utils_js_1.spinner.start(`Running ${installCommand}...`);
        const execAsync = (0, util_1.promisify)(child_process_1.exec);
        try {
            await execAsync(installCommand, {
                cwd: absoluteOutDir,
                // Can't use 'inherit' with async exec, so we'll capture output
                encoding: 'utf8',
            });
            utils_js_1.spinner.stop('Dependencies installed successfully');
        }
        catch (error) {
            utils_js_1.spinner.stop('Failed to install dependencies');
            console.error(`${packageManager} install failed:`, error?.message || error);
            console.log(`You can manually run "${installCommand}" in the created directory`);
        }
        console.info((0, utils_js_1.dedent) `

            Example app created successfully in ${outDir}!

            Next steps:
              cd ${outDir}
              ${packageManager} run dev

            Quick guide:
            ▪︎ Read and edit src/App.tsx to add or customize your rendered Framer components
            ▪︎ Your components are in src/framer/ directory. Run npm run framer to sync changes from Framer
            ▪︎ The app uses Vite + React + TypeScript + Tailwind CSS

            `);
    }
    catch (error) {
        (0, sentry_js_1.notifyError)(error);
        utils_js_1.spinner.error('Failed to create example app');
        throw error;
    }
});
async function configFromFetch({ projectId, externalPackages = [], allExternal = false, agent = '', outDir = undefined, }) {
    utils_js_1.logger.log(`Fetching config for project ${projectId}`);
    const url = process.env.UNFRAMER_SERVER_URL;
    if (url) {
        console.log(`using server url ${url}`);
    }
    const client = await (0, api_client_js_1.createClient)({
        url: url || 'https://unframer.co',
        headers: {
            'X-Agent': agent ||
                (process.env.GITHUB_ACTIONS === 'true'
                    ? 'github-actions'
                    : 'cli'),
        },
    });
    utils_js_1.spinner.start(`Fetching config for project ${projectId}`);
    const { data, error } = await client.api.plugins.reactExportPlugin
        .project({ projectId })
        .get();
    if (error) {
        if (error.status === 402) {
            const rawValue = error.value;
            const buyUrl = rawValue?.buyUrl;
            const message = (() => {
                if (typeof rawValue === 'object' && rawValue?.message) {
                    return String(rawValue.message);
                }
                return 'A React Export subscription is required to download components.';
            })();
            // spinner.error(details)
            utils_js_1.spinner.error(message);
            console.info('');
            console.info('Go to this url to buy the Framer React Export subscription:\n');
            console.info((0, picocolors_1.green)(buyUrl));
            console.info();
            process.exit(1);
            // throw new Error(details, { cause: error })
        }
        utils_js_1.spinner.error('Error fetching project data:');
        console.error(error);
        throw error;
    }
    utils_js_1.spinner.info(`Got Framer project data`);
    const websiteUrl = data?.project?.websiteUrl;
    const projectName = data?.project?.projectName || '';
    if (projectName) {
        utils_js_1.spinner.info(`Using project: ${projectName}`);
    }
    let cwd = path_1.default.resolve(process.cwd(), outDir || 'framer');
    const indexPage = data?.framerWebPages?.find((x) => x.path === '/');
    const componentInstancesInIndexPage = data.componentInstances
        ?.filter((x) => x.webPageId === indexPage?.webPageId)
        .map((x) => {
        const component = data.components.find((c) => {
            return x.componentId === c.id;
        });
        if (!component) {
            console.error(new Error(`cannot find component for instance ${x.componentId}`));
        }
        const componentPathSlug = (0, utils_js_1.componentNameToPath)(component?.name || '');
        const res = {
            ...x,
            controls: x.controls,
            componentPathSlug,
        };
        return res;
    })
        .sort((a, b) => {
        return a.pageOrdering - b.pageOrdering;
    }) || [];
    const config = {
        ...data,
        pageBackgroundColor: data.project?.pageBackgroundColor || '',
        breakpoints: css_js_1.defaultBreakpointSizes,
        outDir,
        externalPackages,
        allExternal,
        projectId: data?.project?.projectId,
        projectName,
        fullFramerProjectId: data?.project?.fullFramerProjectId,
        locales: data?.locales,
        components: Object.fromEntries(data.components.map((c) => [(0, utils_js_1.componentNameToPath)(c.name), c.url])),
        componentBreakpoints: data.breakpoints
            ?.map((b) => {
            const c = data.components.find((c) => c.id === b.componentId);
            if (!c) {
                return;
            }
            return {
                ...b,
                componentName: (0, utils_js_1.componentNameToPath)(c.name),
            };
        })
            .filter(utils_js_1.isTruthy) || [],
        tokens: data.colorStyles,
        componentInstancesInIndexPage,
        framerWebPages: data.framerWebPages || [],
    };
    return { websiteUrl, cwd, config };
}
function findUp(configNames, { cwd }) {
    let currentDir = cwd;
    while (true) {
        for (const configName of configNames) {
            const configPath = path_1.default.join(currentDir, configName);
            if (fs_1.default.existsSync(configPath)) {
                return configPath;
            }
        }
        const parentDir = path_1.default.dirname(currentDir);
        if (parentDir === currentDir) {
            // Reached the root directory
            break;
        }
        currentDir = parentDir;
    }
    return null;
}
//# sourceMappingURL=cli.js.map